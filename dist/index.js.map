{"mappings":"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","sources":["src/index.js"],"sourcesContent":["const axios = require('axios');\nconst M3U8FileParser = require('m3u8-file-parser');\nconst m3u8Parser = new M3U8FileParser();\n\nconst getRemoteFile = async (url) => {\n    try {\n        let { data } = await axios.get(url);\n        return data;\n    } catch (e) {\n        return null;\n    }\n}\n\nconst resolvePlayerResponse = (watchHtml) => {\n    if (!watchHtml) {\n        return '';\n    }\n\n    let matches = watchHtml.match(/ytInitialPlayerResponse = (.*)}}};/);\n    return matches ? matches[1] + '}}}' : '';\n}\n\nconst resoleM3U8Link = (watchHtml) => {\n    if (!watchHtml) {\n        return null;\n    }\n\n    let matches = watchHtml.match(/hlsManifestUrl\":\"(.*\\/file\\/index\\.m3u8)/)\n    return matches ? matches[1] : null;\n}\n\nconst buildDecoder = async (watchHtml) => {\n    if (!watchHtml) {\n        return null;\n    }\n\n    let jsFileUrlMatches = watchHtml.match(/\\/s\\/player\\/[A-Za-z0-9]+\\/[A-Za-z0-9_.]+\\/[A-Za-z0-9_]+\\/base\\.js/);\n\n    if (!jsFileUrlMatches) {\n        return null;\n    }\n\n    let jsFileContent = await getRemoteFile(`https://www.youtube.com${jsFileUrlMatches[0]}`);\n\n    let decodeFunctionMatches = jsFileContent.match(/function.*\\.split\\(\\\"\\\"\\).*\\.join\\(\\\"\\\"\\)}/);\n\n    if (!decodeFunctionMatches) {\n        return null;\n    }\n\n    let decodeFunction = decodeFunctionMatches[0];\n\n    let varNameMatches = decodeFunction.match(/\\.split\\(\\\"\\\"\\);([a-zA-Z0-9]+)\\./);\n\n    if (!varNameMatches) {\n        return null;\n    }\n\n    let varStartIndex = jsFileContent.indexOf(`var ${varNameMatches[1]}={`);\n    if (varStartIndex < 0) {\n        return null;\n    }\n    let varEndIndex = jsFileContent.indexOf('}};', varStartIndex);\n    if (varEndIndex < 0) {\n        return null\n    }\n\n    let varDeclares = jsFileContent.substring(varStartIndex, varEndIndex + 3);\n\n    if (!varDeclares) {\n        return null;\n    }\n\n    return function (signatureCipher) {\n        let params = new URLSearchParams(signatureCipher);\n        let { s: signature, sp: signatureParam = 'signature', url } = Object.fromEntries(params);\n        let decodedSignature = new Function(`\n            \"use strict\";\n            ${varDeclares}\n            return (${decodeFunction})(\"${signature}\");\n        `)();\n\n        return `${url}&${signatureParam}=${encodeURIComponent(decodedSignature)}`;\n    }\n}\n\nconst getInfo = async ({ url, throwOnError = false }) => {\n\n    let videoId = getVideoId({ url });\n\n    if (!videoId) return false;\n\n    let ytApi = 'https://www.youtube.com/watch';\n\n    try {\n        const response = await axios.get(ytApi, {\n            params: { v: videoId }\n        });\n\n        if (!response || response.status != 200 || !response.data) {\n            const error = new Error('Cannot get youtube video response')\n            error.response = response;\n            throw error;\n        }\n\n        let ytInitialPlayerResponse = resolvePlayerResponse(response.data);\n        let parsedResponse = JSON.parse(ytInitialPlayerResponse);\n        let streamingData = parsedResponse.streamingData || {};\n\n        let formats = (streamingData.formats || []).concat(streamingData.adaptiveFormats || []);\n\n        let isEncryptedVideo = !!formats.find(it => !!it.signatureCipher);\n\n        if (isEncryptedVideo) {\n            let decoder = await buildDecoder(response.data);\n\n            if (decoder) {\n                formats = formats.map(it => {\n                    if (it.url || !it.signatureCipher) {\n                        return it;\n                    }\n\n                    it.url = decoder(it.signatureCipher);\n                    delete it.signatureCipher;\n                    return it;\n                });\n            }\n        }\n\n        let result = {\n            videoDetails: parsedResponse.videoDetails || {},\n            formats: formats.filter(format => format.url)\n        };\n\n        if (result.videoDetails.isLiveContent) {\n            try {\n                let m3u8Link = resoleM3U8Link(response.data);\n                if (m3u8Link) {\n                    let m3u8FileContent = await getRemoteFile(m3u8Link);\n\n                    m3u8Parser.read(m3u8FileContent);\n\n                    result.liveData = {\n                        manifestUrl: m3u8Link,\n                        data: m3u8Parser.getResult()\n                    };\n\n                    m3u8Parser.reset();\n                }\n            } catch (e) {\n                if (throwOnError) {\n                    throw e;\n                }\n            }\n        }\n\n        return result;\n    } catch (e) {\n        if (throwOnError) {\n            throw e;\n        }\n\n        return false;\n    }\n};\n\nconst getVideoId = ({ url }) => {\n    let opts = { fuzzy: true };\n\n    if (/youtu\\.?be/.test(url)) {\n\n        // Look first for known patterns\n        let i;\n        let patterns = [\n            /youtu\\.be\\/([^#\\&\\?]{11})/, // youtu.be/<id>\n            /\\?v=([^#\\&\\?]{11})/, // ?v=<id>\n            /\\&v=([^#\\&\\?]{11})/, // &v=<id>\n            /embed\\/([^#\\&\\?]{11})/, // embed/<id>\n            /\\/v\\/([^#\\&\\?]{11})/ // /v/<id>\n        ];\n\n        // If any pattern matches, return the ID\n        for (i = 0; i < patterns.length; ++i) {\n            if (patterns[i].test(url)) {\n                return patterns[i].exec(url)[1];\n            }\n        }\n\n        if (opts.fuzzy) {\n            // If that fails, break it apart by certain characters and look\n            // for the 11 character key\n            let tokens = url.split(/[\\/\\&\\?=#\\.\\s]/g);\n            for (i = 0; i < tokens.length; ++i) {\n                if (/^[^#\\&\\?]{11}$/.test(tokens[i])) {\n                    return tokens[i];\n                }\n            }\n        }\n    }\n\n    return null;\n};\n\nmodule.exports = {\n    getInfo,\n    getVideoId\n};\n"],"names":[],"version":3,"file":"index.js.map"}