{"mappings":"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","sources":["src/index.js"],"sourcesContent":["const axios = require('axios');\nconst M3U8FileParser = require('m3u8-file-parser');\nconst m3u8Parser = new M3U8FileParser();\n\nconst getRemoteFile = async (url) => {\n    try {\n        let { data } = await axios.get(url);\n        return data;\n    } catch (e) {\n        return null;\n    }\n}\n\nconst resolvePlayerResponse = (watchHtml) => {\n    if (!watchHtml) {\n        return '';\n    }\n\n    let matches = watchHtml.match(/ytInitialPlayerResponse = (.*)}}};/);\n    return matches ? matches[1] + '}}}' : '';\n}\n\nconst resoleM3U8Link = (watchHtml) => {\n    if (!watchHtml) {\n        return null;\n    }\n\n    let matches = watchHtml.match(/hlsManifestUrl\":\"(.*\\/file\\/index\\.m3u8)/)\n    return matches ? matches[1] : null;\n}\n\nconst buildDecoder = async (watchHtml) => {\n    if (!watchHtml) {\n        return null;\n    }\n\n    let jsFileUrlMatches = watchHtml.match(/\\/s\\/player\\/[A-Za-z0-9]+\\/[A-Za-z0-9_.]+\\/[A-Za-z0-9_]+\\/base\\.js/);\n\n    if (!jsFileUrlMatches) {\n        return null;\n    }\n\n    let jsFileContent = await getRemoteFile(`https://www.youtube.com${jsFileUrlMatches[0]}`);\n\n    let decodeFunctionMatches = jsFileContent.match(/function.*\\.split\\(\\\"\\\"\\).*\\.join\\(\\\"\\\"\\)}/);\n\n    if (!decodeFunctionMatches) {\n        return null;\n    }\n\n    let decodeFunction = decodeFunctionMatches[0];\n\n    let varNameMatches = decodeFunction.match(/\\.split\\(\\\"\\\"\\);([a-zA-Z0-9]+)\\./);\n\n    if (!varNameMatches) {\n        return null;\n    }\n\n    let varStartIndex = jsFileContent.indexOf(`var ${varNameMatches[1]}={`);\n    if (varStartIndex < 0) {\n        return null;\n    }\n    let varEndIndex = jsFileContent.indexOf('}};', varStartIndex);\n    if (varEndIndex < 0) {\n        return null\n    }\n\n    let varDeclares = jsFileContent.substring(varStartIndex, varEndIndex + 3);\n\n    if (!varDeclares) {\n        return null;\n    }\n\n    return function (signatureCipher) {\n        let params = new URLSearchParams(signatureCipher);\n        let { s: signature, sp: signatureParam = 'signature', url } = Object.fromEntries(params);\n        let decodedSignature = new Function(`\n            \"use strict\";\n            ${varDeclares}\n            return (${decodeFunction})(\"${signature}\");\n        `)();\n\n        return `${url}&${signatureParam}=${encodeURIComponent(decodedSignature)}`;\n    }\n}\n\nconst getInfo = async ({ url, throwOnError = false }) => {\n\n    let videoId = getVideoId({ url });\n\n    if (!videoId) return false;\n\n    let ytApi = 'https://www.youtube.com/watch';\n\n    try {\n        const response = await axios.get(ytApi, {\n            params: { v: videoId }\n        });\n\n        if (!response || response.status != 200 || !response.data) {\n            const error = new Error('Cannot get youtube video response')\n            error.response = response;\n            throw error;\n        }\n\n        let ytInitialPlayerResponse = resolvePlayerResponse(response.data);\n        let parsedResponse = JSON.parse(ytInitialPlayerResponse);\n        let streamingData = parsedResponse.streamingData || {};\n\n        let formats = (streamingData.formats || []).concat(streamingData.adaptiveFormats || []);\n\n        let isEncryptedVideo = !!formats.find(it => !!it.signatureCipher);\n\n        if (isEncryptedVideo) {\n            let decoder = await buildDecoder(response.data);\n\n            if (decoder) {\n                formats = formats.map(it => {\n                    if (it.url || !it.signatureCipher) {\n                        return it;\n                    }\n\n                    it.url = decoder(it.signatureCipher);\n                    delete it.signatureCipher;\n                    return it;\n                });\n            }\n        }\n\n        let result = {\n            videoDetails: parsedResponse.videoDetails || {},\n            formats: formats.filter(format => format.url)\n        };\n\n        if (result.videoDetails.isLiveContent) {\n            try {\n                let m3u8Link = resoleM3U8Link(response.data);\n                if (m3u8Link) {\n                    let m3u8FileContent = await getRemoteFile(m3u8Link);\n\n                    m3u8Parser.read(m3u8FileContent);\n\n                    result.liveData = {\n                        manifestUrl: m3u8Link,\n                        data: m3u8Parser.getResult()\n                    };\n\n                    m3u8Parser.reset();\n                }\n            } catch (e) {\n                if (throwOnError) {\n                    throw e;\n                }\n            }\n        }\n\n        return result;\n    } catch (e) {\n        if (throwOnError) {\n            throw e;\n        }\n\n        return false;\n    }\n};\n\nconst getVideoId = ({ url }) => {\n    let opts = { fuzzy: true };\n\n    if (/youtu\\.?be/.test(url)) {\n\n        // Look first for known patterns\n        let i;\n        let patterns = [\n            /youtu\\.be\\/([^#\\&\\?]{11})/, // youtu.be/<id>\n            /\\?v=([^#\\&\\?]{11})/, // ?v=<id>\n            /\\&v=([^#\\&\\?]{11})/, // &v=<id>\n            /embed\\/([^#\\&\\?]{11})/, // embed/<id>\n            /\\/v\\/([^#\\&\\?]{11})/ // /v/<id>\n        ];\n\n        // If any pattern matches, return the ID\n        for (i = 0; i < patterns.length; ++i) {\n            if (patterns[i].test(url)) {\n                return patterns[i].exec(url)[1];\n            }\n        }\n\n        if (opts.fuzzy) {\n            // If that fails, break it apart by certain characters and look\n            // for the 11 character key\n            let tokens = url.split(/[\\/\\&\\?=#\\.\\s]/g);\n            for (i = 0; i < tokens.length; ++i) {\n                if (/^[^#\\&\\?]{11}$/.test(tokens[i])) {\n                    return tokens[i];\n                }\n            }\n        }\n    }\n\n    return null;\n};\n\nmodule.exports = {\n    getInfo,\n    getVideoId\n};\n"],"names":[],"version":3,"file":"index.js.map"}